library(igraph)
library(qgraph)
library(mvtnorm)
library(mltools)
library(gridExtra)
library(parallel)
library(Matrix) # convenient to deal with sparse matrices, has sparseMatrix() in it
#source(file="simulation_source_functions.R")
#ER_graph
d=100
prob=0.02
set.seed(1)
ER_graph = sample_gnp(n=d, p=prob, directed = FALSE, loops = F)
adj_matrix_ER = as_adjacency_matrix(ER_graph, sparse=F)
p = d
#Edge weights
edge_weights =  matrix(runif(p*p, min=0.5, max=1), ncol=p)
edge_sign =  matrix(sample(c(-1,1), size=p*p, replace=T), ncol=p)
Omega = edge_weights * edge_sign
Omega = Omega * as_adjacency_matrix(ER_graph, sparse=F)
diag(Omega) = 1
#Positive Definite procedure
off_sum = rowSums(abs(Omega))
off_sum = matrix(rep(off_sum, p), ncol=p)
Omega = Omega/(1.5*off_sum)
Omega = Omega %*% diag(sqrt(runif(d, 1, 1.5)))
Omega = (Omega + t(Omega))/2
Sigma = solve(Omega)
min(diag(Sigma))
max(diag(Sigma))
Omega
diag(Omega)
library(knitr)
library(tidyverse)
library(robsel)
library(igraph)
library(qgraph)
library(mvtnorm)
library(mltools)
library(gridExtra)
library(parallel)
library(Matrix) # convenient to deal with sparse matrices, has sparseMatrix() in it
#source(file="simulation_source_functions.R")
#ER_graph
d=100
prob=0.02
set.seed(1)
ER_graph = sample_gnp(n=d, p=prob, directed = FALSE, loops = F)
adj_matrix_ER = as_adjacency_matrix(ER_graph, sparse=F)
p = d
#Edge weights
edge_weights =  matrix(runif(p*p, min=0.5, max=1), ncol=p)
edge_sign =  matrix(sample(c(-1,1), size=p*p, replace=T), ncol=p)
Omega = edge_weights * edge_sign
Omega = Omega * as_adjacency_matrix(ER_graph, sparse=F)
diag(Omega) = 1
#Positive Definite procedure
off_sum = rowSums(abs(Omega))
off_sum = matrix(rep(off_sum, p), ncol=p)
Omega = Omega/(1.5*off_sum)
Omega = Omega %*% diag((runif(d, 1, 1.5)))
Omega = (Omega + t(Omega))/2
Sigma = solve(Omega)
min(diag(Sigma))
max(diag(Sigma))
Omega
diag(Omega)
library(knitr)
library(tidyverse)
library(robsel)
library(igraph)
library(qgraph)
library(mvtnorm)
library(mltools)
library(gridExtra)
library(parallel)
library(Matrix) # convenient to deal with sparse matrices, has sparseMatrix() in it
#source(file="simulation_source_functions.R")
#ER_graph
d=100
prob=0.02
set.seed(1)
ER_graph = sample_gnp(n=d, p=prob, directed = FALSE, loops = F)
adj_matrix_ER = as_adjacency_matrix(ER_graph, sparse=F)
p = d
#Edge weights
edge_weights =  matrix(runif(p*p, min=0.5, max=1), ncol=p)
edge_sign =  matrix(sample(c(-1,1), size=p*p, replace=T), ncol=p)
Omega = edge_weights * edge_sign
Omega = Omega * as_adjacency_matrix(ER_graph, sparse=F)
diag(Omega) = 1
#Positive Definite procedure
off_sum = rowSums(abs(Omega))
off_sum = matrix(rep(off_sum, p), ncol=p)
Omega = Omega/(1.5*off_sum)
Omega = Omega %*% diag((runif(d, 1, 1.5)))
Omega = (Omega + t(Omega))/2
Sigma = solve(Omega)
min(diag(Sigma))
max(diag(Sigma))
library(knitr)
library(tidyverse)
library(robsel)
library(igraph)
library(qgraph)
library(mvtnorm)
library(mltools)
library(gridExtra)
library(parallel)
library(Matrix) # convenient to deal with sparse matrices, has sparseMatrix() in it
#source(file="simulation_source_functions.R")
#ER_graph
d=100
prob=0.02
set.seed(1)
ER_graph = sample_gnp(n=d, p=prob, directed = FALSE, loops = F)
adj_matrix_ER = as_adjacency_matrix(ER_graph, sparse=F)
p = d
#Edge weights
edge_weights =  matrix(runif(p*p, min=0.5, max=1), ncol=p)
edge_sign =  matrix(sample(c(-1,1), size=p*p, replace=T), ncol=p)
Omega = edge_weights * edge_sign
Omega = Omega * as_adjacency_matrix(ER_graph, sparse=F)
diag(Omega) = 1
#Positive Definite procedure
off_sum = rowSums(abs(Omega))
off_sum = matrix(rep(off_sum, p), ncol=p)
Omega = Omega/(1.5*off_sum)
Omega = Omega %*% diag(runif(d, 1, 1.5))
Omega = (Omega + t(Omega))/2
Sigma = solve(Omega)
min(diag(Sigma))
max(diag(Sigma))
library(knitr)
library(tidyverse)
library(robsel)
library(igraph)
library(qgraph)
library(mvtnorm)
library(mltools)
library(gridExtra)
library(parallel)
library(Matrix) # convenient to deal with sparse matrices, has sparseMatrix() in it
#source(file="simulation_source_functions.R")
#ER_graph
d=100
prob=0.02
set.seed(1)
ER_graph = sample_gnp(n=d, p=prob, directed = FALSE, loops = F)
adj_matrix_ER = as_adjacency_matrix(ER_graph, sparse=F)
p = d
#Edge weights
edge_weights =  matrix(runif(p*p, min=0.5, max=1), ncol=p)
edge_sign =  matrix(sample(c(-1,1), size=p*p, replace=T), ncol=p)
Omega = edge_weights * edge_sign
Omega = Omega * as_adjacency_matrix(ER_graph, sparse=F)
diag(Omega) = 1
#Positive Definite procedure
off_sum = rowSums(abs(Omega))
off_sum = matrix(rep(off_sum, p), ncol=p)
Omega = Omega/(1.5*off_sum)
Omega
Omega = Omega %*% diag(runif(d, 1, 1.5))
Omega = (Omega + t(Omega))/2
Sigma = solve(Omega)
min(diag(Sigma))
max(diag(Sigma))
library(knitr)
library(tidyverse)
library(robsel)
library(igraph)
library(qgraph)
library(mvtnorm)
library(mltools)
library(gridExtra)
library(parallel)
library(Matrix) # convenient to deal with sparse matrices, has sparseMatrix() in it
#source(file="simulation_source_functions.R")
#ER_graph
d=100
prob=0.02
set.seed(1)
ER_graph = sample_gnp(n=d, p=prob, directed = FALSE, loops = F)
adj_matrix_ER = as_adjacency_matrix(ER_graph, sparse=F)
p = d
#Edge weights
edge_weights =  matrix(runif(p*p, min=0.5, max=1), ncol=p)
edge_sign =  matrix(sample(c(-1,1), size=p*p, replace=T), ncol=p)
Omega = edge_weights * edge_sign
Omega = Omega * as_adjacency_matrix(ER_graph, sparse=F)
diag(Omega) = 1
#Positive Definite procedure
off_sum = rowSums(abs(Omega))
off_sum = matrix(rep(off_sum, p), ncol=p)
Omega = Omega/(1.5*off_sum)
diag(Omega) = 1
Omega = Omega %*% diag(runif(d, 1, 1.5))
Omega = (Omega + t(Omega))/2
Sigma = solve(Omega)
min(diag(Sigma))
max(diag(Sigma))
diag(Omega)
100/1226
cranlogs::cran_downloads("robsel")
install.packages("rqPen")
library(rqPen)
scad
scad
scad_deriv
scad(0.5)
scad(1)
scad(1.5)
scad(c(1.5,2))
scad_deriv(c(0,1.5))
scad_deriv(c(0,3.6))
u[] = 1
u = 1
u[] = 0
u
scad_deriv(3,1)
scad_deriv(-3,1)
scad_deriv(.001,2)
library(huge)
install.packages("huge")
library(huge)
test = huge.generator()
test$omega != 0
(test$omega != 0) == test$theta
(test$omega != 0) == (test$theta)
test$theta
omega = test$omega != 0
omega
diag(omega) = 0
image(omega)
image(test$theta)
library(Matrix)
theta = Matrix(test$theta, sparse = F)
image(theta)
omega
is.na(omega)
sum(is.na(omega))
image(omega)
image(theta)
theta
omega
omega - theta
omega
test$omega
?huge.generator
huge.generator
image(Matrix(theta))
image(theta)
clus = huge.generator(graph="cluster")
diag(clus$omega)
sort(diag(clus$omega))
random = huge.generator(graph="random")
sort(diag(random))
sort(diag(random$omega))
band_g
band_g = huge.generator(graph="band")
diag(sort(band_g$omega))
band_g$omega
sort(diag(band_g$omega))
scalefree_g = huge.generator(graph="scale-free")
sort(diag(scalefree_g$omega))
library(rqReg)
library(rqPen)
?scad_deriv
scad
?scad
install.packages("ncvreg")
library(ncvreg)
?ncvreg
ncvreg
library(huge)
test = huge.generator()
omega = test$omega
diag(omega=0)
diag(omega) = 0
max(abs(omega))
image(omega)
min(omega)
max(abs(omega))
3.7*0.1
0.1*0.05
seq(0.05, 1, )
seq(0.05, 1, 5 )
?seq
seq(from = 0.05, to = 1,
length.out = 5)
library(pracma)
logseq(1 * 0.01, 1, 10)
seq(1 * 0.01, 1, 10)
seq(1 * 0.01, 1, length.out=10)
seq(2 * 0.01, 2, length.out=10)
sqrt(log(100))
library(pracma)
logseq(0.01,0.5,10)
library(ncvreg)
?cv.ncvreg
cv.ncvreg
ncvreg
ncvreg
?ncvreg
setupLambda
0.01*3.7
choose(50,2)
choose(50,2) * 0.95
choose(50,2) * 0.95 * 0.1
?huge.generator
library(huge)
?huge.generator
library(flare)
install.packages("flare")
library(flare)
?flare
sugm.generator()
?sugm.generator
sugm.generator
?sugm
?sugm.select
library(huge)
test = huge.generator(graph="band")
diag(test$omega)
sort(diag(test$omega))
cranlogs::cran_downloads("robsel")
cranlogs::cran_downloads("robsel", "last-month")
library(huge)
huge
huge.generator
library(huge)
test = huge.generator()
diag(test$omega)
huge.generator
library(flare)
sugm.generator
cov2cor
?cov2cor
library(huge)
?huge.generator
huge.generator
huge.generator()
test =huge.generator()
diag(test$omega)
library(flare)
?sugm.select
install.packages("robsel")
1e-4
1e-4 - 10^-4
library(huge)
?huge.generator
library(qgraph)
?EBICglasso
library(CVglasso)
?CVglasso
library(huge)
?huge.generator
ceiling(50/20)
?bs
library(splines)
?bs
?bs
library(minqa)
cranlogs::cran_downloads("robsel")
cranlogs::cran_downloads("robsel", "last-month")
library(readr)
single_region_estimates_20160524_153000_fmri_flat_preprocessed_deadrat <- read_csv("Desktop/QFunC/rat-results/20160524_153000_fmri_flat_preprocessed_deadrat/single_region_estimates-20160524_153000_fmri_flat_preprocessed_deadrat.csv")
View(single_region_estimates_20160524_153000_fmri_flat_preprocessed_deadrat)
hist(single_region_estimates_20160524_153000_fmri_flat_preprocessed_deadrat$V1)
1:10.1
library(flare)
?lad
?slim.lad.ladm.scr.btr
?slim
# DREAM R Script
library(Rcpp)
library(knitr)
library(tidyverse)
library(robsel)
library(qgraph)
library(igraph)
library(glasso)
library(gridExtra)
library(CVglasso)
library(Matrix) # convenient to deal with sparse matrices, has sparseMatrix() in it
setwd("~/robsel-reproducible/gene-network")
########
### read in, clean, and construct data
########
# In Silico Network
# read in observed data
data.net1.orig <- read.table("Net1-In-silico/input-data/net1_expression_data.tsv", header=T, sep="\t")
data.net1.orig <- scale(data.net1.orig)
net1.TF <- read.table("Net1-In-silico/input-data/net1_transcription_factors.tsv")$V1
net1.gold.standard <- read.table("Net1-In-silico/gold-standard/DREAM5_Network1_edges_only.tsv", header=F, sep="\t")
# data.net1.orig <- read.table("Net3-Ecoli/input-data/net3_expression_data.tsv", header=T, sep="\t")
# data.net1.orig <- scale(data.net1.orig)
# net1.TF <- read.table("Net3-Ecoli/input-data/net3_transcription_factors.tsv")$V1
# net1.gold.standard <- read.table("Net3-Ecoli/gold-standard/DREAM5_Network3_edges_only.tsv", header=F, sep="\t")
# data.net1.orig <- read.table("Net4-Scerevisiae/input-data/net4_expression_data.tsv", header=T, sep="\t")
# data.net1.orig <- scale(data.net1.orig)
# net1.TF <- read.table("Net4-Scerevisiae/input-data/net4_transcription_factors.tsv")$V1
# net1.gold.standard <- read.table("Net4-Scerevisiae/gold-standard/DREAM5_Network4_edges_only.tsv", header=F, sep="\t")
net1.gene.names <- colnames(data.net1.orig)
true.net1 <- diag(length(net1.gene.names))
colnames(true.net1) <- net1.gene.names
rownames(true.net1) <- net1.gene.names
for (i in 1:length(net1.gold.standard$V1)) {
tf.row <- net1.gold.standard[i,]
true.net1[tf.row$V1, tf.row$V2] <- tf.row$V3
true.net1[tf.row$V2, tf.row$V1] <- tf.row$V3
}
data.net1.subset <- data.net1.orig[,net1.TF]
true.net1.subset <- true.net1[net1.TF,net1.TF]
data.net1.subset.cov <- cov(data.net1.subset)
net1.n <- nrow(data.net1.subset)
ptm <- proc.time()
robsel.lambda <- robsel(as.matrix(data.net1.subset), alpha = 0.9)
net1.robsel <- glasso(data.net1.subset.cov, rho=robsel.lambda, penalize.diagonal=F)
net1.robsel.graph <- net1.robsel$wi
net1.robsel.time <- proc.time() - ptm
net1.robsel.time
net1.robsel.TP <- sum(net1.robsel.graph[upper.tri(net1.robsel.graph)]!=0 & true.net1.subset[upper.tri(true.net1.subset)]!=0)
net1.robsel.TP
net1.robsel.total <- sum(net1.robsel.graph[upper.tri(net1.robsel.graph)]!=0)
net1.robsel.total
ptm <- proc.time()
net1.EBIC.graph.10 <- EBICglasso(S=data.net1.subset.cov, n=net1.n, gamma=0.5, penalize.diagonal = F, nlambda=10, lambda.min.ratio=0.05)
net1.EBIC.10.time <- proc.time() - ptm
net1.EBIC.10.time
net1.EBIC.graph.10.TP <- sum(net1.EBIC.graph.10[upper.tri(net1.robsel.graph)]!=0 & true.net1.subset[upper.tri(true.net1.subset)]!=0)
net1.EBIC.graph.10.TP
net1.EBIC.graph.10.total <- sum(net1.EBIC.graph.10[upper.tri(net1.robsel.graph)]!=0)
net1.EBIC.graph.10.total
cv.numlamb <- 10
ptm <- proc.time()
net1.cv.graph <- CVglasso(X=data.net1.subset, diagonal = F, nlam=cv.numlamb, lam.min.ratio=0.05)$Omega
net1.cv.time <- proc.time() - ptm
net1.cv.time
net1.cv.graph.TP <- sum(net1.cv.graph[upper.tri(net1.cv.graph)]!=0 & true.net1.subset[upper.tri(true.net1.subset)]!=0)
net1.cv.graph.TP
net1.cv.graph.total <- sum(net1.cv.graph[upper.tri(net1.cv.graph)]!=0)
net1.cv.graph.total
ptm <- proc.time()
net1.testing.graph <- testing_fit(as.matrix(data.net1.subset), alpha = 0.9)
net1.testing.time <- proc.time() - ptm
net1.testing.time
net1.testing.graph.TP <- sum(net1.testing.graph[upper.tri(net1.testing.graph)]!=0 & true.net1.subset[upper.tri(true.net1.subset)]!=0)
net1.testing.graph.TP
net1.testing.graph.total <- sum(net1.testing.graph[upper.tri(net1.testing.graph)]!=0)
net1.testing.graph.total
source(file="../simulation/simulation_source_functions.R")
data.net1.orig <- read.table("Net1-In-silico/input-data/net1_expression_data.tsv", header=T, sep="\t")
data.net1.orig <- scale(data.net1.orig)
net1.TF <- read.table("Net1-In-silico/input-data/net1_transcription_factors.tsv")$V1
net1.gold.standard <- read.table("Net1-In-silico/gold-standard/DREAM5_Network1_edges_only.tsv", header=F, sep="\t")
# data.net1.orig <- read.table("Net3-Ecoli/input-data/net3_expression_data.tsv", header=T, sep="\t")
# data.net1.orig <- scale(data.net1.orig)
# net1.TF <- read.table("Net3-Ecoli/input-data/net3_transcription_factors.tsv")$V1
# net1.gold.standard <- read.table("Net3-Ecoli/gold-standard/DREAM5_Network3_edges_only.tsv", header=F, sep="\t")
# data.net1.orig <- read.table("Net4-Scerevisiae/input-data/net4_expression_data.tsv", header=T, sep="\t")
# data.net1.orig <- scale(data.net1.orig)
# net1.TF <- read.table("Net4-Scerevisiae/input-data/net4_transcription_factors.tsv")$V1
# net1.gold.standard <- read.table("Net4-Scerevisiae/gold-standard/DREAM5_Network4_edges_only.tsv", header=F, sep="\t")
net1.gene.names <- colnames(data.net1.orig)
true.net1 <- diag(length(net1.gene.names))
colnames(true.net1) <- net1.gene.names
rownames(true.net1) <- net1.gene.names
for (i in 1:length(net1.gold.standard$V1)) {
tf.row <- net1.gold.standard[i,]
true.net1[tf.row$V1, tf.row$V2] <- tf.row$V3
true.net1[tf.row$V2, tf.row$V1] <- tf.row$V3
}
data.net1.subset <- data.net1.orig[,net1.TF]
true.net1.subset <- true.net1[net1.TF,net1.TF]
data.net1.subset.cov <- cov(data.net1.subset)
net1.n <- nrow(data.net1.subset)
ptm <- proc.time()
robsel.lambda <- robsel(as.matrix(data.net1.subset), alpha = 0.9)
net1.robsel <- glasso(data.net1.subset.cov, rho=robsel.lambda, penalize.diagonal=F)
net1.robsel.graph <- net1.robsel$wi
net1.robsel.time <- proc.time() - ptm
net1.robsel.time
net1.robsel.TP <- sum(net1.robsel.graph[upper.tri(net1.robsel.graph)]!=0 & true.net1.subset[upper.tri(true.net1.subset)]!=0)
net1.robsel.TP
net1.robsel.total <- sum(net1.robsel.graph[upper.tri(net1.robsel.graph)]!=0)
net1.robsel.total
ptm <- proc.time()
net1.EBIC.graph.10 <- EBICglasso(S=data.net1.subset.cov, n=net1.n, gamma=0.5, penalize.diagonal = F, nlambda=10, lambda.min.ratio=0.05)
net1.EBIC.10.time <- proc.time() - ptm
net1.EBIC.10.time
net1.EBIC.graph.10.TP <- sum(net1.EBIC.graph.10[upper.tri(net1.robsel.graph)]!=0 & true.net1.subset[upper.tri(true.net1.subset)]!=0)
net1.EBIC.graph.10.TP
net1.EBIC.graph.10.total <- sum(net1.EBIC.graph.10[upper.tri(net1.robsel.graph)]!=0)
net1.EBIC.graph.10.total
cv.numlamb <- 10
ptm <- proc.time()
net1.cv.graph <- CVglasso(X=data.net1.subset, diagonal = F, nlam=cv.numlamb, lam.min.ratio=0.05)$Omega
net1.cv.time <- proc.time() - ptm
net1.cv.time
net1.cv.graph.TP <- sum(net1.cv.graph[upper.tri(net1.cv.graph)]!=0 & true.net1.subset[upper.tri(true.net1.subset)]!=0)
net1.cv.graph.TP
net1.cv.graph.total <- sum(net1.cv.graph[upper.tri(net1.cv.graph)]!=0)
net1.cv.graph.total
ptm <- proc.time()
net1.testing.graph <- testing_fit(as.matrix(data.net1.subset), alpha = 0.9)
net1.testing.time <- proc.time() - ptm
net1.testing.time
net1.testing.graph.TP <- sum(net1.testing.graph[upper.tri(net1.testing.graph)]!=0 & true.net1.subset[upper.tri(true.net1.subset)]!=0)
net1.testing.graph.TP
net1.testing.graph.total <- sum(net1.testing.graph[upper.tri(net1.testing.graph)]!=0)
net1.testing.graph.total
